{"pageProps":{"id":"19","title":"Fibonacci number","datetime":"2017-07-10T13:20:54.575Z","summary":"最近看的文章中，有兩篇[1][2]剛好都提到#Fibonacci_number ，其中一篇用了#DP 的做法，自己也試著推導一次，順便記錄下來。\n\n\n>Fibonacci number:\n>\n>0, ","content":"<p>最近看的文章中，有兩篇[1][2]剛好都提到#Fibonacci_number ，其中一篇用了#DP 的做法，自己也試著推導一次，順便記錄下來。</p>\n<blockquote>\n<p>Fibonacci number:</p>\n<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…</p>\n<p>Fn = Fn-1 + Fn-2</p>\n</blockquote>\n<p>一開始看到 Fibonacci number 最直覺的做法就是用#Recursive</p>\n<p>#程式 碼如下：</p>\n<pre><code class=\"language-javascript\">const fib = n => {\n  if (n &#x3C; 2) {\n    return 1\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n\n//or\nconst fib = n => n &#x3C; 2 ? 1 : fib(n - 1) + fib(n - 2);\n</code></pre>\n<p>這樣的做法在數字越大就會越來越慢，因為在計算的過程中，越小的數字會被重複計算越多次</p>\n<pre><code>fib(6)\n  |---fib(5)\n  |     |---fib(4)\n  |     |     |---fib(3)\n  |     |     |     |---fib(2)\n  |     |     |     |---fib(1)\n  |     |     |---fib(2)\n  |     |---fib(3)\n  |           |---fib(2)\n  |           |---fib(1)\n  |---fib(4)\n        |---fib(3)\n        |     |---fib(2)\n        |     |---fib(1)\n        |---fib(2)\n</code></pre>\n<p>以fib(6)為例</p>\n<ul>\n<li>fib(5)算1次</li>\n<li>fib(4)算2次</li>\n<li>fib(3)算3次\n…</li>\n</ul>\n<p>所以在[1]的文中，作者的方法是讓Fibonacci function有cache機制。如果直接修改Fibonacci function的話可能會像這樣：</p>\n<pre><code class=\"language-javascript\">let m = {};\nconst fib = n => {\n  if (m[n]) {\n    return m[n];\n  }\n  if (n &#x3C; 2) {\n    return 1;\n  }\n  m[n] = fib(n-1) + fib(n-2);\n  return m[n];\n}\n</code></pre>\n<p>可是我們並不想直接將cache機制加在Fibonacci function中，而是另外建立一個function，用途是將傳入的function變成有#cache 機制。\n但這裡作者指出另一個問題</p>\n<blockquote>\n<p>因為Fibonacci function是recursive，所以要確保return時呼叫的>Fibonacci function也是有cache機制的Fibonacci function。</p>\n</blockquote>\n<p>[1]的回應部分有提到一種寫起來比較簡單的做法，但這裡，我想記錄一下用Y combinator做法的推導過程。</p>\n<blockquote>\n<p>Used in this way the Y combinator implements simple recursion. In the lambda calculus it is not possible to refer to the definition of a function in a function body. Recursion may only be achieved by passing in a function as a parameter. The Y combinator demonstrates this style of programming.</p>\n<p>— <a href=\"https://en.wikipedia.org/wiki/Fixed-point_combinator\">Wikipedia Fixed-point combinator</a></p>\n</blockquote>\n<p>首先，我們先將Fibonacci function做一點變形。</p>\n<pre><code class=\"language-javascript\">const afib = f => n => {\n  if (n &#x3C; 2) {\n    return 1;\n  }\n  return f(n -1) + f(n - 2);\n}\n\n//or\nconst afib = f => n => n &#x3C; 2 ? 1 : f(n - 1) + f(n - 2);\n</code></pre>\n<p>現在他已經不是一個真正Fibonacci function，但還保有其外觀。接下來我們需要個function可以讓變成真正的Fibonacci function，並且在其中加入cache機制。</p>\n<p><code>const memoFib = makeMemoFib(afib);</code></p>\n<pre><code class=\"language-javascript\">// a function to create realFib function\nconst makeMemoFib = (f, m = {}) => {\n  const memoFib = (n) => {\n    if (m[n]) {\n      return m[n]\n    }\n    const fib = f(memoFib);\n    m[n] = fib(n);\n    return m[n];\n  };\n  return memoFib;\n};\n\n// simplify\nconst makeMemoFib = (f, m = {}) => {\n  const memoFib = (n) => {\n    if (m[n]) {\n      return m[n]\n    }\n    m[n] = f(memoFib)(n);\n    return m[n];\n  };\n  return memoFib;\n};\n</code></pre>\n<p>我們建立一個makeMemoFib的function，讓我們傳入被變形過的Fibonacci function，並且回傳一個有cache機制的Fibonacci function (memoFib)。</p>\n<p>為了滿足“In the lambda calculus it is not possible to refer to the definition of a function in a function body”，我們將makeMemoFib簡化，不用另外宣告一個fib。</p>\n<p>但是我們還是宣告了memoFib，所以我們還是需要再進一步簡化它，而可以幫助我們簡化的是：</p>\n<p><code>memoFib = makeMemoFib(f, m);</code></p>\n<pre><code class=\"language-javascript\">const makeMemoFib = (f, m = {}) => {\n  return (n) => {\n    if (m[n]) {\n      return m[n]\n    }\n    m[n] = f(makeMemoFib(f, m))(n);\n    return m[n];\n  };\n};\n</code></pre>\n<p>這樣已經完成大半了，我們在稍作整理一下</p>\n<pre><code class=\"language-javascript\">const makeMemoFib = (f, m = {}) => (n) => {\n  if (m[n]) {\n    return m[n]\n  }\n  m[n] = f(makeMemoFib(f, m))(n);\n  return m[n];\n};\n\n// simplify again\nconst makeMemoFib = (f, m = {}) => (n) => {\n  return m[n] ? m[n] : (m[n] = f(makeMemoFib(f, m))(n));\n};\n\n// one more\nconst makeMemoFib = (f, m = {}) => (n) => m[n] ? m[n] : (m[n] = f(makeMemoFib(f, m))(n));\n</code></pre>\n<p>現在我們已經簡化到只剩makeMemoFib，雖然這樣還不算是一個合格的Y combinator，但對我們來說已經夠用，接下來只要把我們變形過的afib丟進去，就可以得到一個有cache機制的Fibonacci function了</p>\n<p><code>const memoFib = makeMemoFib(afib);</code></p>\n<p>這樣做的過程還蠻像在算#數學 的，還可以試試算階層的function，也可以用類似的方法推導出來。</p>\n<p>[2]的話則是用了ES2015的 Generator function，內容也很精彩，做法就完全不一樣了。</p>\n<p>Reference:</p>\n<ul>\n<li>[1] <a href=\"https://medium.com/@rayshih771012/functional-%E8%A8%88%E7%AE%97%E6%80%9D%E7%B6%AD-recursion-%E8%88%87-dp-7ed4c28e0e32#.n97xutc3h\">Functional 計算思維 — Recursion 與 DP  -  Ray Shih</a></li>\n<li>[2] <a href=\"https://medium.com/javascript-scene/7-surprising-things-i-learned-writing-a-fibonacci-generator-4886a5c87710#.x6uig6qrq\">7 Surprising Things I Learned Writing a Fibonacci Generator in JavaScript  - Eric Elliott</a></li>\n<li>[3] <a href=\"http://kestas.kuliukas.com/YCombinatorExplained/\">The Y Combinator explained with JavaScript</a></li>\n</ul>\n"},"__N_SSG":true}